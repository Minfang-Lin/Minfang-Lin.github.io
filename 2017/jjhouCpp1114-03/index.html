<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> C++ 新标准 11/14 语言新特性 - 03 · 叶卡林娜的部落格</title><meta name="description" content="C++ 新标准 11/14 语言新特性 - 03 - Minfang Lin"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://leavesite.com/atom.xml" title="叶卡林娜的部落格"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/Minfang-Lin" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">C++ 新标准 11/14 语言新特性 - 03</h1><div class="post-info">Jan 15, 2017</div><div class="post-content"><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>使用decltype可以让编译器找出一个表达式结果的类型，这个很像是对于<strong>typeof</strong>的需求（GUN C当中有typeof，但是不是C++标准里的东西）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">float</span>&gt; coll;</div><div class="line"><span class="keyword">decltype</span>(coll)::value_type elem;</div><div class="line"></div><div class="line"><span class="comment">// 在C++11之前，无法通过对象取得type，而是必须确切知道它的类型，所以只能写成这样</span></div><div class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">float</span>&gt;::value_type elem;</div></pre></td></tr></table></figure>
<blockquote><p>By using the new decltype keyword, you can <u>let the compiler find out the type of an expression.</u> This is the realization of often requested <strong>typeof</strong> feature.<br>One application of decltype is ①<u>to declare return types</u>. Another is to use it ②<u>in metaprogramming</u> or to ③<u>pass the type of a lambda</u>.</p>
<footer><strong>Nicolai M.Josuttis</strong><cite>the C++ Standard Library 2/e</cite></footer></blockquote>
<h3 id="①-decltype-used-to-declare-return-types"><a href="#①-decltype-used-to-declare-return-types" class="headerlink" title="① decltype, used to declare return types"></a>① decltype, used to declare return types</h3><p>标准库里面的add()函数，加的两样东西都是一样的，比如int+int，但下面这种情况就不一样了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</div><div class="line"><span class="keyword">decltype</span>(x+y) add(T1 x, T2 y); <span class="comment">// 由于x和y未知，所以编译通不过</span></div></pre></td></tr></table></figure>
<p>x和y可以是两个不同的类型，比如青菜加萝卜。能不能相加在于程序员对T1和T2的设计。在C++11之前因为不知道T1和T2是什么，所以不知道怎么设置返回类型，有了decltype就可以了（当然这只是让编译可以通过，如果x和y真的不能相加，调用它的代码编译时还是会报错）。而上面的代码，由于编译器是顺序编译的，看到x和y的时候不知道它们是什么，所以编译还是通不过。需要用下面的写法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</div><div class="line">auto add(T1 x, T2 y)-&gt;decltype(x+y);</div></pre></td></tr></table></figure>
<h3 id="②-decltype-used-in-metaprogramming"><a href="#②-decltype-used-in-metaprogramming" class="headerlink" title="② decltype, used in metaprogramming"></a>② decltype, used in metaprogramming</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T obj)</span> </span>&#123;</div><div class="line">    <span class="comment">// 当我们手上有type，可取其inner typedef，没问题</span></div><div class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">float</span>&gt;::value_type elem1;</div><div class="line">    </div><div class="line">    <span class="comment">// 面对obj取其class type的inner typedef，因为如今我们有了工具decltype</span></div><div class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">float</span>&gt; coll;</div><div class="line">    <span class="keyword">decltype</span>(coll)::value_type elem2;</div><div class="line">    </div><div class="line">    <span class="comment">// 有了decltype也可以这样写</span></div><div class="line">    typedef typename decltype(obj)::iterator iType;</div><div class="line">    <span class="comment">// typedef typename T::iterator iType;</span></div><div class="line">    <span class="keyword">decltype</span>(obj) anotherOby(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果使用者使用的时候，指定进入的是复数<code>test(complex&lt;int&gt;())</code>，由于复数没有迭代器，上面的代码还是会报错。所以，模板只是半成品，还需要看调用它的代码。</p>
<h3 id="③-decltype-used-to-pass-the-type-of-a-lambda"><a href="#③-decltype-used-to-pass-the-type-of-a-lambda" class="headerlink" title="③ decltype, used to pass the type of a lambda"></a>③ decltype, used to pass the type of a lambda</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> Person&amp; p1, <span class="keyword">const</span> Person&amp; p2) &#123;</div><div class="line">                <span class="keyword">return</span> p1.lastname()&lt;p2.lastname() ||</div><div class="line">                        (p1.lastname()==p2.lastname() &amp;&amp;</div><div class="line">                        p1.firstname()&lt;p2.firstname());</div><div class="line">            &#125;; </div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;Person,delctype(cmp)&gt; coll&lt;cmp&gt;;</div></pre></td></tr></table></figure>
<p>面对lambda，我们手上往往只有object，没有type，要获得其type就得借助于decltype。</p>
<h2 id="lambdas"><a href="#lambdas" class="headerlink" title="lambdas"></a>lambdas</h2><p>C++11引入了lambdas，它允许程序员定义出inline function，可以作为参数或者本地变量使用。lambdas改变了程序员对C++标准库的使用方式。我们在使用C++标准库的时候，往往会写一些小东西来声明我们的意图，比如sort时怎么比大小就可以由程序员来定义，通过函数对象（仿函数）来实现，也可以用过lambda来写。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">[] &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello lambda"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这看起来是一个函数，其实是一个对象，所以不会有输出。可以写成下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">[] &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello lambda"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125; ();  <span class="comment">// prints "hello lambda"</span></div></pre></td></tr></table></figure>
<p>这里的小括号不是产生临时对象的意思，而是当做函数执行的意思。当然上面的代码并没有什么意义，要输出直接cout就可以了，所以一般的用法是下面这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">auto</span> l = [] &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello lambda"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">l(); <span class="comment">// prints "hello lambda"</span></div></pre></td></tr></table></figure>
<h3 id="lambdas表达式的完整形式"><a href="#lambdas表达式的完整形式" class="headerlink" title="lambdas表达式的完整形式"></a>lambdas表达式的完整形式</h3><p><strong>[…](…)mutable<em><sub>opt</sub> throwSpec<sub>opt</sub></em> -&gt; <em>retType<sub>opt</sub></em> {…}</strong></p>
<ul>
<li>[]为lambda introducer，即lambda导入器（导入符号），说明这是一个lambda表达式。里面可以放lambda表达式需要取用（捕获）的外部变量。可以有值捕获和引用捕获两种方式。</li>
<li>opt表示mutable、throwSpec、retType是可选的（可写可不写），但如果出现其中任一的话，必须写上前面的小括号指定参数。如果三个都没有，小括号可写可不写（视是否有参数而定）。</li>
<li>retType用于描述返回值类型，由于lambda表达式写法特殊，由中括号开始，所以没有办法在前面指定返回类型。所以换作这种方式。</li>
<li>对于值捕获的变量，lambda不会改变其值，如果希望改变其值，需要加上mutable。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</div><div class="line"><span class="keyword">auto</span> f = [id]() <span class="keyword">mutable</span> &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id:"</span> &lt;&lt; id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    ++id;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">id = <span class="number">42</span>;</div><div class="line">f();</div><div class="line">f();</div><div class="line">f();</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"><span class="comment">// 运行结果</span></div><div class="line"><span class="comment">// id:0</span></div><div class="line"><span class="comment">// id:1</span></div><div class="line"><span class="comment">// id:2</span></div><div class="line"><span class="comment">// 42</span></div><div class="line"><span class="comment">// 如果不加mutable，会报错Error: increment of read-only variabel 'id'</span></div></pre></td></tr></table></figure>
<p>lambda表达式的type是一种匿名函数对象（仿函数），对于每个lambda表达式都有唯一的type与之对应。如果想定义这个type的一个对象，则需要用到模板（templates）或者auto关键词。如果确实需要知道具体是什么type，可以使用decltype()。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> Person&amp; p1, <span class="keyword">const</span> Person&amp; p2) &#123;</div><div class="line">                <span class="keyword">return</span> p1.lastname()&lt;p2.lastname()||</div><div class="line">                        (p1.lastname()==p2.lastname()&amp;&amp;</div><div class="line">             			 p1.firstname()&lt;p2.firstname());</div><div class="line">            &#125;;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;Person,<span class="keyword">decltype</span>(cmp)&gt;coll(cmp);</div></pre></td></tr></table></figure>
<h2 id="Variadic-Templates"><a href="#Variadic-Templates" class="headerlink" title="Variadic Templates"></a>Variadic Templates</h2><h3 id="例1：使用variadic-templates处理不定类型不定数量的参数"><a href="#例1：使用variadic-templates处理不定类型不定数量的参数" class="headerlink" title="例1：使用variadic templates处理不定类型不定数量的参数"></a>例1：使用variadic templates处理不定类型不定数量的参数</h3><p>从C++11开始，模板可以接受数量不定的参数，这就是所谓的variadic templates。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// function 1</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printX</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"></div><div class="line"><span class="comment">// function 2</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printX</span><span class="params">(<span class="keyword">const</span> T&amp; firstArg, <span class="keyword">const</span> Types&amp;... args)</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; firstArg &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// print first argument</span></div><div class="line">    printX(args...);           <span class="comment">// call printX() for remaining arguments</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// function 3</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printX</span><span class="params">(<span class="keyword">const</span> Types&amp;... args)</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>
<p>函数2比较特化，所以函数2和函数3可以共存，且函数3永远不会被调用。</p>
<h3 id="例2：使用variadic-templates重写printf"><a href="#例2：使用variadic-templates重写printf" class="headerlink" title="例2：使用variadic templates重写printf()"></a>例2：使用variadic templates重写printf()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// http://stackoverflow.com/questions/3634379/variadic-templates</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (*s) &#123;</div><div class="line">        <span class="keyword">if</span> (*s==<span class="string">'%'</span> &amp;&amp; *(++s)!=<span class="string">'%'</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"invaild format string: missing arguments"</span>);</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *s++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, T value, Args... args)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (*s) &#123;</div><div class="line">        <span class="keyword">if</span> (*s==<span class="string">'%'</span> &amp;&amp; *(++s)!=<span class="string">'%'</span>) &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value;</div><div class="line">            <span class="built_in">printf</span>(++s, args...); <span class="comment">// call even when *s==0 to detect extra arguments</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *s++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span>* pi = <span class="keyword">new</span> <span class="keyword">int</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d %s %p %f\n"</span>, <span class="number">15</span>, <span class="string">"This is Ace."</span>, pi, <span class="number">3.14159</span>);</div></pre></td></tr></table></figure>
<p><code>char* s</code>接收到的是控制字符串（其实根本没用到它来控制输出的格式，全部都是通过cout处理的输出，但为了模拟C语言的printf，所以还是需要的），后面的参数被分解为一个（value）和一包（args）。</p>
<h3 id="例3：设计max函数，用于检测一堆数据中最大的那个（一）"><a href="#例3：设计max函数，用于检测一堆数据中最大的那个（一）" class="headerlink" title="例3：设计max函数，用于检测一堆数据中最大的那个（一）"></a>例3：设计max函数，用于检测一堆数据中最大的那个（一）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cout</span> &lt;&lt; max(&#123;<span class="number">57</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">100</span>, <span class="number">20</span>, <span class="number">18</span>&#125;) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="comment">// 这里为了配合后面max函数接收的是initializer_list，所以需要给initializer_list的参数</span></div></pre></td></tr></table></figure>
<p>如果参数types皆同，则无数动用variadic templates，只需要使用initializer_list<t>就可以了，以下是标准库中的做法：</t></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ...\4.9.2\include\c++\bits\predefined_oops.h</span></div><div class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Iter_less_iter</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Iterator1, <span class="keyword">typename</span> _Iterator2&gt;</div><div class="line">  	<span class="keyword">bool</span></div><div class="line">  	<span class="keyword">operator</span>()(_Iterator1 __it1, _Iterator2 __it2) <span class="keyword">const</span></div><div class="line">  	&#123; <span class="keyword">return</span> *__it1 &lt; *__it2; &#125;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">inline</span> _Iter_less_iter</div><div class="line">__iter_less_iter()</div><div class="line">&#123; <span class="keyword">return</span> _Iter_less_iter(); &#125;  </div><div class="line">  </div><div class="line"><span class="comment">// ...\4.9.2\include\c++\bits\stl_algo.h	</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator, <span class="keyword">typename</span> _Compare&gt;</div><div class="line">_ForwardIterator</div><div class="line">__max_element(_ForwardIterator __first, _ForwardIterator __last,</div><div class="line">              _Compare __comp)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span> __first;</div><div class="line">    _ForwardIterator __result = __first;</div><div class="line">    <span class="keyword">while</span> (++__first != __last)</div><div class="line">        <span class="keyword">if</span> (__comp(__result, __first))</div><div class="line">  		__result = __first;</div><div class="line">    <span class="keyword">return</span> __result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator&gt;</div><div class="line"><span class="keyword">inline</span> _ForwardIterator</div><div class="line">max_element(_ForwardIterator __first, _ForwardIterator __last)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> __max_element(__first, __last, </div><div class="line">                       __iter_less_iter());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</div><div class="line"><span class="keyword">inline</span> _Tp</div><div class="line">max(<span class="built_in">initializer_list</span>&lt;_Tp&gt; __l)</div><div class="line">&#123; <span class="keyword">return</span> *max_element(__l.begin(), __l.end()); &#125;</div></pre></td></tr></table></figure>
<h3 id="例4：设计max函数，用于检测一堆数据中最大的那个（二）"><a href="#例4：设计max函数，用于检测一堆数据中最大的那个（二）" class="headerlink" title="例4：设计max函数，用于检测一堆数据中最大的那个（二）"></a>例4：设计max函数，用于检测一堆数据中最大的那个（二）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cout</span> &lt;&lt; maximum(<span class="number">57</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">100</span>, <span class="number">20</span>, <span class="number">18</span>) &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
<p>直接使用标准库里面的max：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// http://stackoverflow.com/questions/3634379/variadic-templates	</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> n, Args... args)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::max(n, maximum(args...));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>利用不断调用std::max()而完成最大值的获取。</p>
<p>同样地，如果参数type相同，则不需动用variadic templates。</p>
<h3 id="例5：类模板，使用不同方式处理first和last元素"><a href="#例5：类模板，使用不同方式处理first和last元素" class="headerlink" title="例5：类模板，使用不同方式处理first和last元素"></a>例5：类模板，使用不同方式处理first和last元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cout</span> &lt;&lt; make_tuple(<span class="number">7.5</span>, <span class="built_in">string</span>(<span class="string">"hello"</span>), <span class="built_in">bitset</span>&lt;<span class="number">16</span>&gt;(<span class="number">377</span>), <span class="number">42</span>);</div><div class="line"><span class="comment">// 需要实现的打印效果 [7.5,hello,0000000101111001,42]</span></div></pre></td></tr></table></figure>
<p>要进行这样的处理，必须知道处理的元素有几个，所以需要使用sizeof…()获取元素的个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// output operator for tuples</span></div><div class="line"><span class="keyword">template</span> &lt;Typename... Args&gt;</div><div class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t) &#123;</div><div class="line">    os &lt;&lt; <span class="string">"["</span>;</div><div class="line">    PRINT_TUPLE&lt;<span class="number">0</span>, <span class="keyword">sizeof</span>...(Args), Args...&gt;::print(os, t);</div><div class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">"]"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// boost: util/printtuple.hpp</span></div><div class="line"><span class="comment">// helper: print element with index IDX of tuple with MAX elements</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> IDX, <span class="keyword">int</span> MAX, <span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PRINT_TUPLE</span> &#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t)</span> </span>&#123;</div><div class="line">        os &lt;&lt; get&lt;IDX&gt;(t) &lt;&lt; (IDX+<span class="number">1</span>==MAX ? <span class="string">""</span> : <span class="string">","</span>);</div><div class="line">        PRINT_TUPLE&lt;IDX+<span class="number">1</span>, MAX, Args...&gt;::print(os, t);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// partial specialization to end the recursion</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> MAX, <span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PRINT_TUPLE</span>&lt;MAX, MAX, Args...&gt; &#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t)</span> </span>&#123;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="例6：用于递归继承"><a href="#例6：用于递归继承" class="headerlink" title="例6：用于递归继承"></a>例6：用于递归继承</h3><p>递归调用处理的都是参数，所以使用函数模板；递归继承处理的都是类型，所以使用类模板。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>;</span></div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;&gt; &#123;</span> &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 将数据分为一个和一包，一个用于声明变量，一包再做成一个tuple，用于继承</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;Head, Tail...&gt; </span></div><div class="line"><span class="class">	:</span><span class="keyword">private</span> tuple&lt;Tail...&gt; <span class="comment">// 使用私有继承，因为这样做只是为了满足递归继承，并不是is-a的关系</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</div><div class="line">    </div><div class="line"> <span class="keyword">protected</span>:	</div><div class="line">    Head m_head;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">    tuple() &#123; &#125;</div><div class="line">    tuple(Head v, Tail... vtail) </div><div class="line">      : m_head(v), inherited(vtail...) &#123; &#125;</div><div class="line">         </div><div class="line">    <span class="comment">// typename Head::type head() &#123; return m_head; &#125;</span></div><div class="line">    <span class="comment">// [Error] no type named 'type' in 'class std::basic_string&lt;char&gt;'</span></div><div class="line">    <span class="comment">// 上面这样写会报错，因为像int、float并不知道Head::type是什么，所以可以用decltype</span></div><div class="line">    <span class="comment">// auto head()-&gt;decltype(m_head) &#123; return m_head; &#125;</span></div><div class="line">    <span class="comment">// 但其实可以直接用Head，因为返回类型就是Head</span></div><div class="line">    <span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_head; &#125; </div><div class="line">            </div><div class="line">    <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;  <span class="comment">// 强转后得到的就是tail的部分</span></div><div class="line">    </div><div class="line">&#125;;</div><div class="line"></div><div class="line">tuple&lt;<span class="keyword">int</span>, <span class="keyword">float</span>, <span class="built_in">string</span>&gt;t(<span class="number">41</span>, <span class="number">6.3</span>, <span class="string">"nico"</span>);</div></pre></td></tr></table></figure>
<p>对于t，继承关系如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">        tuple&lt;&gt;</div><div class="line">           ↑</div><div class="line">     tuple&lt;string&gt;</div><div class="line">  string m_head(&quot;nico&quot;);</div><div class="line">           ↑</div><div class="line">  tuple&lt;float, string&gt;</div><div class="line">   float m_head(6.3);</div><div class="line">           ↑ </div><div class="line">tuple&lt;int, float, string&gt;</div><div class="line">     int m_head(41);</div></pre></td></tr></table></figure>
<h3 id="例7：用于递归复合"><a href="#例7：用于递归复合" class="headerlink" title="例7：用于递归复合"></a>例7：用于递归复合</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt; <span class="class"><span class="keyword">class</span> <span class="title">tup</span>;</span></div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">tup</span>&lt;&gt; &#123;</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">tup</span>&lt;Head, Tail...&gt; </span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">typedef</span> tup&lt;Tail...&gt; composited;</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">    composited m_tail;	</div><div class="line">    Head m_head;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">    tup() &#123; &#125;</div><div class="line">    tup(Head v, Tail... vtail) </div><div class="line">      : m_tail(vtail...), m_head(v) &#123; &#125;</div><div class="line">         </div><div class="line">    <span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_head; &#125;  	          </div><div class="line">    <span class="function">composited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_tail; &#125; </div><div class="line">    <span class="comment">// 这里需要用引用，不然修改值时因为改的是拷贝版本，原始版本不会被改变</span></div><div class="line">      </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="C-keywords"><a href="#C-keywords" class="headerlink" title="C++ keywords"></a>C++ keywords</h2><blockquote>
<p><a href="http://en.cppreference.com/w/cpp/keyword" target="_blank" rel="external">http://en.cppreference.com/w/cpp/keyword</a></p>
</blockquote>
<p>The end!</p>
</div></article></div></section><footer><div class="paginator"><a href="/2017/jjhouCpp1114-04/" class="prev">PREV</a><a href="/2017/jjhouCpp1114-02/" class="next">NEXT</a></div><div data-thread-key="2017/jjhouCpp1114-03/" data-title="C++ 新标准 11/14 语言新特性 - 03" data-url="http://leavesite.com/2017/jjhouCpp1114-03/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"leavesite"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2013 - 2017 <a href="http://leavesite.com">Minfang Lin</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>