<!DOCTYPE html>
<html>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="decltype使用decltype可以让编译器找出一个表达式结果的类型，这个很像是对于typeof的需求（GUN C当中有typeof，但是不是C++标准里的东西）。 map&amp;lt;string,float&amp;gt; coll;decltype(coll)::value_type elem;// 在C++11之前，无法通过对象取得type，而是必须确切知道它的类型，所以只能写成这样map&amp;lt;s">
<meta name="keywords" content="Cpp,侯捷,11&#x2F;14">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 新标准 11&#x2F;14 语言新特性 - 03">
<meta property="og:url" content="http://leavesite.com/2017/jjhouCpp1114-03/index.html">
<meta property="og:site_name" content="叶卡林娜的部落格">
<meta property="og:description" content="decltype使用decltype可以让编译器找出一个表达式结果的类型，这个很像是对于typeof的需求（GUN C当中有typeof，但是不是C++标准里的东西）。 map&amp;lt;string,float&amp;gt; coll;decltype(coll)::value_type elem;// 在C++11之前，无法通过对象取得type，而是必须确切知道它的类型，所以只能写成这样map&amp;lt;s">
<meta property="og:updated_time" content="2017-04-14T14:03:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ 新标准 11&#x2F;14 语言新特性 - 03">
<meta name="twitter:description" content="decltype使用decltype可以让编译器找出一个表达式结果的类型，这个很像是对于typeof的需求（GUN C当中有typeof，但是不是C++标准里的东西）。 map&amp;lt;string,float&amp;gt; coll;decltype(coll)::value_type elem;// 在C++11之前，无法通过对象取得type，而是必须确切知道它的类型，所以只能写成这样map&amp;lt;s">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>C++ 新标准 11/14 语言新特性 - 03</title>
    <!-- styles -->
    <link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/lib/meslo-LG/styles.css">
    <link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
    <!-- jquery -->
    <script src="/lib/jquery/jquery.min.js"></script>
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/Minfang-Lin">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2017/jjhouCpp1114-04/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li>
        
        
        <li><a class="icon" href="/2017/jjhouCpp1114-02/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://leavesite.com/2017/jjhouCpp1114-03/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://leavesite.com/2017/jjhouCpp1114-03/&text=C++ 新标准 11/14 语言新特性 - 03"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://leavesite.com/2017/jjhouCpp1114-03/&title=C++ 新标准 11/14 语言新特性 - 03"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://leavesite.com/2017/jjhouCpp1114-03/&is_video=false&description=C++ 新标准 11/14 语言新特性 - 03"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C++ 新标准 11/14 语言新特性 - 03&body=Check out this article: http://leavesite.com/2017/jjhouCpp1114-03/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://leavesite.com/2017/jjhouCpp1114-03/&title=C++ 新标准 11/14 语言新特性 - 03"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://leavesite.com/2017/jjhouCpp1114-03/&title=C++ 新标准 11/14 语言新特性 - 03"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://leavesite.com/2017/jjhouCpp1114-03/&title=C++ 新标准 11/14 语言新特性 - 03"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://leavesite.com/2017/jjhouCpp1114-03/&title=C++ 新标准 11/14 语言新特性 - 03"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://leavesite.com/2017/jjhouCpp1114-03/&name=C++ 新标准 11/14 语言新特性 - 03&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#decltype"><span class="toc-number">1.</span> <span class="toc-text">decltype</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#①-decltype-used-to-declare-return-types"><span class="toc-number">1.1.</span> <span class="toc-text">① decltype, used to declare return types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#②-decltype-used-in-metaprogramming"><span class="toc-number">1.2.</span> <span class="toc-text">② decltype, used in metaprogramming</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#③-decltype-used-to-pass-the-type-of-a-lambda"><span class="toc-number">1.3.</span> <span class="toc-text">③ decltype, used to pass the type of a lambda</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambdas"><span class="toc-number">2.</span> <span class="toc-text">lambdas</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lambdas表达式的完整形式"><span class="toc-number">2.1.</span> <span class="toc-text">lambdas表达式的完整形式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Variadic-Templates"><span class="toc-number">3.</span> <span class="toc-text">Variadic Templates</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例1：使用variadic-templates处理不定类型不定数量的参数"><span class="toc-number">3.1.</span> <span class="toc-text">例1：使用variadic templates处理不定类型不定数量的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例2：使用variadic-templates重写printf"><span class="toc-number">3.2.</span> <span class="toc-text">例2：使用variadic templates重写printf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例3：设计max函数，用于检测一堆数据中最大的那个（一）"><span class="toc-number">3.3.</span> <span class="toc-text">例3：设计max函数，用于检测一堆数据中最大的那个（一）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例4：设计max函数，用于检测一堆数据中最大的那个（二）"><span class="toc-number">3.4.</span> <span class="toc-text">例4：设计max函数，用于检测一堆数据中最大的那个（二）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例5：类模板，使用不同方式处理first和last元素"><span class="toc-number">3.5.</span> <span class="toc-text">例5：类模板，使用不同方式处理first和last元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例6：用于递归继承"><span class="toc-number">3.6.</span> <span class="toc-text">例6：用于递归继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例7：用于递归复合"><span class="toc-number">3.7.</span> <span class="toc-text">例7：用于递归复合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-keywords"><span class="toc-number">4.</span> <span class="toc-text">C++ keywords</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        C++ 新标准 11/14 语言新特性 - 03
    </h1>



    <div class="meta">
      <!--
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name"><i class="fa fa-pencil"></i> Minfang Lin </span>
      </span>
      -->
      
    <div class="postdate">
        <time datetime="2017-01-15T12:00:00.000Z" itemprop="datePublished">2017-01-15</time>
    </div>


      
    <div class="article-tag">
        <i class="fa fa-tags"></i>
        <a class="tag-link" href="/tags/11-14/">11/14</a>, <a class="tag-link" href="/tags/Cpp/">Cpp</a>, <a class="tag-link" href="/tags/侯捷/">侯捷</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>使用decltype可以让编译器找出一个表达式结果的类型，这个很像是对于<strong>typeof</strong>的需求（GUN C当中有typeof，但是不是C++标准里的东西）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">float</span>&gt; coll;</div><div class="line"><span class="keyword">decltype</span>(coll)::value_type elem;</div><div class="line"></div><div class="line"><span class="comment">// 在C++11之前，无法通过对象取得type，而是必须确切知道它的类型，所以只能写成这样</span></div><div class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">float</span>&gt;::value_type elem;</div></pre></td></tr></table></figure>
<blockquote><p>By using the new decltype keyword, you can <u>let the compiler find out the type of an expression.</u> This is the realization of often requested <strong>typeof</strong> feature.<br>One application of decltype is ①<u>to declare return types</u>. Another is to use it ②<u>in metaprogramming</u> or to ③<u>pass the type of a lambda</u>.</p>
<footer><strong>Nicolai M.Josuttis</strong><cite>the C++ Standard Library 2/e</cite></footer></blockquote>
<h3 id="①-decltype-used-to-declare-return-types"><a href="#①-decltype-used-to-declare-return-types" class="headerlink" title="① decltype, used to declare return types"></a>① decltype, used to declare return types</h3><p>标准库里面的add()函数，加的两样东西都是一样的，比如int+int，但下面这种情况就不一样了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</div><div class="line"><span class="keyword">decltype</span>(x+y) add(T1 x, T2 y); <span class="comment">// 由于x和y未知，所以编译通不过</span></div></pre></td></tr></table></figure>
<p>x和y可以是两个不同的类型，比如青菜加萝卜。能不能相加在于程序员对T1和T2的设计。在C++11之前因为不知道T1和T2是什么，所以不知道怎么设置返回类型，有了decltype就可以了（当然这只是让编译可以通过，如果x和y真的不能相加，调用它的代码编译时还是会报错）。而上面的代码，由于编译器是顺序编译的，看到x和y的时候不知道它们是什么，所以编译还是通不过。需要用下面的写法：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</div><div class="line">auto add(T1 x, T2 y)-&gt;decltype(x+y);</div></pre></td></tr></table></figure>
<h3 id="②-decltype-used-in-metaprogramming"><a href="#②-decltype-used-in-metaprogramming" class="headerlink" title="② decltype, used in metaprogramming"></a>② decltype, used in metaprogramming</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T obj)</span> </span>&#123;</div><div class="line">    <span class="comment">// 当我们手上有type，可取其inner typedef，没问题</span></div><div class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">float</span>&gt;::value_type elem1;</div><div class="line">    </div><div class="line">    <span class="comment">// 面对obj取其class type的inner typedef，因为如今我们有了工具decltype</span></div><div class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">float</span>&gt; coll;</div><div class="line">    <span class="keyword">decltype</span>(coll)::value_type elem2;</div><div class="line">    </div><div class="line">    <span class="comment">// 有了decltype也可以这样写</span></div><div class="line">    typedef typename decltype(obj)::iterator iType;</div><div class="line">    <span class="comment">// typedef typename T::iterator iType;</span></div><div class="line">    <span class="keyword">decltype</span>(obj) anotherOby(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果使用者使用的时候，指定进入的是复数<code>test(complex&lt;int&gt;())</code>，由于复数没有迭代器，上面的代码还是会报错。所以，模板只是半成品，还需要看调用它的代码。</p>
<h3 id="③-decltype-used-to-pass-the-type-of-a-lambda"><a href="#③-decltype-used-to-pass-the-type-of-a-lambda" class="headerlink" title="③ decltype, used to pass the type of a lambda"></a>③ decltype, used to pass the type of a lambda</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> Person&amp; p1, <span class="keyword">const</span> Person&amp; p2) &#123;</div><div class="line">                <span class="keyword">return</span> p1.lastname()&lt;p2.lastname() ||</div><div class="line">                        (p1.lastname()==p2.lastname() &amp;&amp;</div><div class="line">                        p1.firstname()&lt;p2.firstname());</div><div class="line">            &#125;; </div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;Person,delctype(cmp)&gt; coll&lt;cmp&gt;;</div></pre></td></tr></table></figure>
<p>面对lambda，我们手上往往只有object，没有type，要获得其type就得借助于decltype。</p>
<h2 id="lambdas"><a href="#lambdas" class="headerlink" title="lambdas"></a>lambdas</h2><p>C++11引入了lambdas，它允许程序员定义出inline function，可以作为参数或者本地变量使用。lambdas改变了程序员对C++标准库的使用方式。我们在使用C++标准库的时候，往往会写一些小东西来声明我们的意图，比如sort时怎么比大小就可以由程序员来定义，通过函数对象（仿函数）来实现，也可以用过lambda来写。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">[] &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello lambda"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这看起来是一个函数，其实是一个对象，所以不会有输出。可以写成下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line">[] &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello lambda"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125; ();  <span class="comment">// prints "hello lambda"</span></div></pre></td></tr></table></figure>
<p>这里的小括号不是产生临时对象的意思，而是当做函数执行的意思。当然上面的代码并没有什么意义，要输出直接cout就可以了，所以一般的用法是下面这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">auto</span> l = [] &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello lambda"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">l(); <span class="comment">// prints "hello lambda"</span></div></pre></td></tr></table></figure>
<h3 id="lambdas表达式的完整形式"><a href="#lambdas表达式的完整形式" class="headerlink" title="lambdas表达式的完整形式"></a>lambdas表达式的完整形式</h3><p><strong>[…](…)mutable<em><sub>opt</sub> throwSpec<sub>opt</sub></em> -&gt; <em>retType<sub>opt</sub></em> {…}</strong></p>
<ul>
<li>[]为lambda introducer，即lambda导入器（导入符号），说明这是一个lambda表达式。里面可以放lambda表达式需要取用（捕获）的外部变量。可以有值捕获和引用捕获两种方式。</li>
<li>opt表示mutable、throwSpec、retType是可选的（可写可不写），但如果出现其中任一的话，必须写上前面的小括号指定参数。如果三个都没有，小括号可写可不写（视是否有参数而定）。</li>
<li>retType用于描述返回值类型，由于lambda表达式写法特殊，由中括号开始，所以没有办法在前面指定返回类型。所以换作这种方式。</li>
<li>对于值捕获的变量，lambda不会改变其值，如果希望改变其值，需要加上mutable。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</div><div class="line"><span class="keyword">auto</span> f = [id]() <span class="keyword">mutable</span> &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id:"</span> &lt;&lt; id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    ++id;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">id = <span class="number">42</span>;</div><div class="line">f();</div><div class="line">f();</div><div class="line">f();</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"><span class="comment">// 运行结果</span></div><div class="line"><span class="comment">// id:0</span></div><div class="line"><span class="comment">// id:1</span></div><div class="line"><span class="comment">// id:2</span></div><div class="line"><span class="comment">// 42</span></div><div class="line"><span class="comment">// 如果不加mutable，会报错Error: increment of read-only variabel 'id'</span></div></pre></td></tr></table></figure>
<p>lambda表达式的type是一种匿名函数对象（仿函数），对于每个lambda表达式都有唯一的type与之对应。如果想定义这个type的一个对象，则需要用到模板（templates）或者auto关键词。如果确实需要知道具体是什么type，可以使用decltype()。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">auto</span> cmp = [](<span class="keyword">const</span> Person&amp; p1, <span class="keyword">const</span> Person&amp; p2) &#123;</div><div class="line">                <span class="keyword">return</span> p1.lastname()&lt;p2.lastname()||</div><div class="line">                        (p1.lastname()==p2.lastname()&amp;&amp;</div><div class="line">             			 p1.firstname()&lt;p2.firstname());</div><div class="line">            &#125;;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;Person,<span class="keyword">decltype</span>(cmp)&gt;coll(cmp);</div></pre></td></tr></table></figure>
<h2 id="Variadic-Templates"><a href="#Variadic-Templates" class="headerlink" title="Variadic Templates"></a>Variadic Templates</h2><h3 id="例1：使用variadic-templates处理不定类型不定数量的参数"><a href="#例1：使用variadic-templates处理不定类型不定数量的参数" class="headerlink" title="例1：使用variadic templates处理不定类型不定数量的参数"></a>例1：使用variadic templates处理不定类型不定数量的参数</h3><p>从C++11开始，模板可以接受数量不定的参数，这就是所谓的variadic templates。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// function 1</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printX</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"></div><div class="line"><span class="comment">// function 2</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printX</span><span class="params">(<span class="keyword">const</span> T&amp; firstArg, <span class="keyword">const</span> Types&amp;... args)</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; firstArg &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// print first argument</span></div><div class="line">    printX(args...);           <span class="comment">// call printX() for remaining arguments</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// function 3</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printX</span><span class="params">(<span class="keyword">const</span> Types&amp;... args)</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>
<p>函数2比较特化，所以函数2和函数3可以共存，且函数3永远不会被调用。</p>
<h3 id="例2：使用variadic-templates重写printf"><a href="#例2：使用variadic-templates重写printf" class="headerlink" title="例2：使用variadic templates重写printf()"></a>例2：使用variadic templates重写printf()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// http://stackoverflow.com/questions/3634379/variadic-templates</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (*s) &#123;</div><div class="line">        <span class="keyword">if</span> (*s==<span class="string">'%'</span> &amp;&amp; *(++s)!=<span class="string">'%'</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"invaild format string: missing arguments"</span>);</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *s++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, T value, Args... args)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (*s) &#123;</div><div class="line">        <span class="keyword">if</span> (*s==<span class="string">'%'</span> &amp;&amp; *(++s)!=<span class="string">'%'</span>) &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value;</div><div class="line">            <span class="built_in">printf</span>(++s, args...); <span class="comment">// call even when *s==0 to detect extra arguments</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *s++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span>* pi = <span class="keyword">new</span> <span class="keyword">int</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d %s %p %f\n"</span>, <span class="number">15</span>, <span class="string">"This is Ace."</span>, pi, <span class="number">3.14159</span>);</div></pre></td></tr></table></figure>
<p><code>char* s</code>接收到的是控制字符串（其实根本没用到它来控制输出的格式，全部都是通过cout处理的输出，但为了模拟C语言的printf，所以还是需要的），后面的参数被分解为一个（value）和一包（args）。</p>
<h3 id="例3：设计max函数，用于检测一堆数据中最大的那个（一）"><a href="#例3：设计max函数，用于检测一堆数据中最大的那个（一）" class="headerlink" title="例3：设计max函数，用于检测一堆数据中最大的那个（一）"></a>例3：设计max函数，用于检测一堆数据中最大的那个（一）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cout</span> &lt;&lt; max(&#123;<span class="number">57</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">100</span>, <span class="number">20</span>, <span class="number">18</span>&#125;) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="comment">// 这里为了配合后面max函数接收的是initializer_list，所以需要给initializer_list的参数</span></div></pre></td></tr></table></figure>
<p>如果参数types皆同，则无数动用variadic templates，只需要使用initializer_list<t>就可以了，以下是标准库中的做法：</t></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// ...\4.9.2\include\c++\bits\predefined_oops.h</span></div><div class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Iter_less_iter</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Iterator1, <span class="keyword">typename</span> _Iterator2&gt;</div><div class="line">  	<span class="keyword">bool</span></div><div class="line">  	<span class="keyword">operator</span>()(_Iterator1 __it1, _Iterator2 __it2) <span class="keyword">const</span></div><div class="line">  	&#123; <span class="keyword">return</span> *__it1 &lt; *__it2; &#125;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">inline</span> _Iter_less_iter</div><div class="line">__iter_less_iter()</div><div class="line">&#123; <span class="keyword">return</span> _Iter_less_iter(); &#125;  </div><div class="line">  </div><div class="line"><span class="comment">// ...\4.9.2\include\c++\bits\stl_algo.h	</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator, <span class="keyword">typename</span> _Compare&gt;</div><div class="line">_ForwardIterator</div><div class="line">__max_element(_ForwardIterator __first, _ForwardIterator __last,</div><div class="line">              _Compare __comp)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (__first == __last) <span class="keyword">return</span> __first;</div><div class="line">    _ForwardIterator __result = __first;</div><div class="line">    <span class="keyword">while</span> (++__first != __last)</div><div class="line">        <span class="keyword">if</span> (__comp(__result, __first))</div><div class="line">  		__result = __first;</div><div class="line">    <span class="keyword">return</span> __result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _ForwardIterator&gt;</div><div class="line"><span class="keyword">inline</span> _ForwardIterator</div><div class="line">max_element(_ForwardIterator __first, _ForwardIterator __last)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> __max_element(__first, __last, </div><div class="line">                       __iter_less_iter());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</div><div class="line"><span class="keyword">inline</span> _Tp</div><div class="line">max(<span class="built_in">initializer_list</span>&lt;_Tp&gt; __l)</div><div class="line">&#123; <span class="keyword">return</span> *max_element(__l.begin(), __l.end()); &#125;</div></pre></td></tr></table></figure>
<h3 id="例4：设计max函数，用于检测一堆数据中最大的那个（二）"><a href="#例4：设计max函数，用于检测一堆数据中最大的那个（二）" class="headerlink" title="例4：设计max函数，用于检测一堆数据中最大的那个（二）"></a>例4：设计max函数，用于检测一堆数据中最大的那个（二）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cout</span> &lt;&lt; maximum(<span class="number">57</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">100</span>, <span class="number">20</span>, <span class="number">18</span>) &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
<p>直接使用标准库里面的max：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// http://stackoverflow.com/questions/3634379/variadic-templates	</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> n, Args... args)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::max(n, maximum(args...));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>利用不断调用std::max()而完成最大值的获取。</p>
<p>同样地，如果参数type相同，则不需动用variadic templates。</p>
<h3 id="例5：类模板，使用不同方式处理first和last元素"><a href="#例5：类模板，使用不同方式处理first和last元素" class="headerlink" title="例5：类模板，使用不同方式处理first和last元素"></a>例5：类模板，使用不同方式处理first和last元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="built_in">cout</span> &lt;&lt; make_tuple(<span class="number">7.5</span>, <span class="built_in">string</span>(<span class="string">"hello"</span>), <span class="built_in">bitset</span>&lt;<span class="number">16</span>&gt;(<span class="number">377</span>), <span class="number">42</span>);</div><div class="line"><span class="comment">// 需要实现的打印效果 [7.5,hello,0000000101111001,42]</span></div></pre></td></tr></table></figure>
<p>要进行这样的处理，必须知道处理的元素有几个，所以需要使用sizeof…()获取元素的个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="comment">// output operator for tuples</span></div><div class="line"><span class="keyword">template</span> &lt;Typename... Args&gt;</div><div class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t) &#123;</div><div class="line">    os &lt;&lt; <span class="string">"["</span>;</div><div class="line">    PRINT_TUPLE&lt;<span class="number">0</span>, <span class="keyword">sizeof</span>...(Args), Args...&gt;::print(os, t);</div><div class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">"]"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// boost: util/printtuple.hpp</span></div><div class="line"><span class="comment">// helper: print element with index IDX of tuple with MAX elements</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> IDX, <span class="keyword">int</span> MAX, <span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PRINT_TUPLE</span> &#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t)</span> </span>&#123;</div><div class="line">        os &lt;&lt; get&lt;IDX&gt;(t) &lt;&lt; (IDX+<span class="number">1</span>==MAX ? <span class="string">""</span> : <span class="string">","</span>);</div><div class="line">        PRINT_TUPLE&lt;IDX+<span class="number">1</span>, MAX, Args...&gt;::print(os, t);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// partial specialization to end the recursion</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> MAX, <span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PRINT_TUPLE</span>&lt;MAX, MAX, Args...&gt; &#123;</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="built_in">std</span>::ostream&amp; os, <span class="keyword">const</span> tuple&lt;Args...&gt;&amp; t)</span> </span>&#123;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="例6：用于递归继承"><a href="#例6：用于递归继承" class="headerlink" title="例6：用于递归继承"></a>例6：用于递归继承</h3><p>递归调用处理的都是参数，所以使用函数模板；递归继承处理的都是类型，所以使用类模板。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>;</span></div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;&gt; &#123;</span> &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 将数据分为一个和一包，一个用于声明变量，一包再做成一个tuple，用于继承</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">tuple</span>&lt;Head, Tail...&gt; </span></div><div class="line"><span class="class">	:</span><span class="keyword">private</span> tuple&lt;Tail...&gt; <span class="comment">// 使用私有继承，因为这样做只是为了满足递归继承，并不是is-a的关系</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">typedef</span> tuple&lt;Tail...&gt; inherited;</div><div class="line">    </div><div class="line"> <span class="keyword">protected</span>:	</div><div class="line">    Head m_head;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">    tuple() &#123; &#125;</div><div class="line">    tuple(Head v, Tail... vtail) </div><div class="line">      : m_head(v), inherited(vtail...) &#123; &#125;</div><div class="line">         </div><div class="line">    <span class="comment">// typename Head::type head() &#123; return m_head; &#125;</span></div><div class="line">    <span class="comment">// [Error] no type named 'type' in 'class std::basic_string&lt;char&gt;'</span></div><div class="line">    <span class="comment">// 上面这样写会报错，因为像int、float并不知道Head::type是什么，所以可以用decltype</span></div><div class="line">    <span class="comment">// auto head()-&gt;decltype(m_head) &#123; return m_head; &#125;</span></div><div class="line">    <span class="comment">// 但其实可以直接用Head，因为返回类型就是Head</span></div><div class="line">    <span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_head; &#125; </div><div class="line">            </div><div class="line">    <span class="function">inherited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;  <span class="comment">// 强转后得到的就是tail的部分</span></div><div class="line">    </div><div class="line">&#125;;</div><div class="line"></div><div class="line">tuple&lt;<span class="keyword">int</span>, <span class="keyword">float</span>, <span class="built_in">string</span>&gt;t(<span class="number">41</span>, <span class="number">6.3</span>, <span class="string">"nico"</span>);</div></pre></td></tr></table></figure>
<p>对于t，继承关系如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">        tuple&lt;&gt;</div><div class="line">           ↑</div><div class="line">     tuple&lt;string&gt;</div><div class="line">  string m_head(&quot;nico&quot;);</div><div class="line">           ↑</div><div class="line">  tuple&lt;float, string&gt;</div><div class="line">   float m_head(6.3);</div><div class="line">           ↑ </div><div class="line">tuple&lt;int, float, string&gt;</div><div class="line">     int m_head(41);</div></pre></td></tr></table></figure>
<h3 id="例7：用于递归复合"><a href="#例7：用于递归复合" class="headerlink" title="例7：用于递归复合"></a>例7：用于递归复合</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt; <span class="class"><span class="keyword">class</span> <span class="title">tup</span>;</span></div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">tup</span>&lt;&gt; &#123;</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">tup</span>&lt;Head, Tail...&gt; </span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">typedef</span> tup&lt;Tail...&gt; composited;</div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">    composited m_tail;	</div><div class="line">    Head m_head;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">    tup() &#123; &#125;</div><div class="line">    tup(Head v, Tail... vtail) </div><div class="line">      : m_tail(vtail...), m_head(v) &#123; &#125;</div><div class="line">         </div><div class="line">    <span class="function">Head <span class="title">head</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_head; &#125;  	          </div><div class="line">    <span class="function">composited&amp; <span class="title">tail</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_tail; &#125; </div><div class="line">    <span class="comment">// 这里需要用引用，不然修改值时因为改的是拷贝版本，原始版本不会被改变</span></div><div class="line">      </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="C-keywords"><a href="#C-keywords" class="headerlink" title="C++ keywords"></a>C++ keywords</h2><blockquote>
<p><a href="http://en.cppreference.com/w/cpp/keyword" target="_blank" rel="external">http://en.cppreference.com/w/cpp/keyword</a></p>
</blockquote>
<p>The end!</p>

  </div>
</article>


    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/Minfang-Lin">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#decltype"><span class="toc-number">1.</span> <span class="toc-text">decltype</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#①-decltype-used-to-declare-return-types"><span class="toc-number">1.1.</span> <span class="toc-text">① decltype, used to declare return types</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#②-decltype-used-in-metaprogramming"><span class="toc-number">1.2.</span> <span class="toc-text">② decltype, used in metaprogramming</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#③-decltype-used-to-pass-the-type-of-a-lambda"><span class="toc-number">1.3.</span> <span class="toc-text">③ decltype, used to pass the type of a lambda</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambdas"><span class="toc-number">2.</span> <span class="toc-text">lambdas</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lambdas表达式的完整形式"><span class="toc-number">2.1.</span> <span class="toc-text">lambdas表达式的完整形式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Variadic-Templates"><span class="toc-number">3.</span> <span class="toc-text">Variadic Templates</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#例1：使用variadic-templates处理不定类型不定数量的参数"><span class="toc-number">3.1.</span> <span class="toc-text">例1：使用variadic templates处理不定类型不定数量的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例2：使用variadic-templates重写printf"><span class="toc-number">3.2.</span> <span class="toc-text">例2：使用variadic templates重写printf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例3：设计max函数，用于检测一堆数据中最大的那个（一）"><span class="toc-number">3.3.</span> <span class="toc-text">例3：设计max函数，用于检测一堆数据中最大的那个（一）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例4：设计max函数，用于检测一堆数据中最大的那个（二）"><span class="toc-number">3.4.</span> <span class="toc-text">例4：设计max函数，用于检测一堆数据中最大的那个（二）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例5：类模板，使用不同方式处理first和last元素"><span class="toc-number">3.5.</span> <span class="toc-text">例5：类模板，使用不同方式处理first和last元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例6：用于递归继承"><span class="toc-number">3.6.</span> <span class="toc-text">例6：用于递归继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例7：用于递归复合"><span class="toc-number">3.7.</span> <span class="toc-text">例7：用于递归复合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-keywords"><span class="toc-number">4.</span> <span class="toc-text">C++ keywords</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://leavesite.com/2017/jjhouCpp1114-03/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://leavesite.com/2017/jjhouCpp1114-03/&text=C++ 新标准 11/14 语言新特性 - 03"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://leavesite.com/2017/jjhouCpp1114-03/&title=C++ 新标准 11/14 语言新特性 - 03"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://leavesite.com/2017/jjhouCpp1114-03/&is_video=false&description=C++ 新标准 11/14 语言新特性 - 03"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=C++ 新标准 11/14 语言新特性 - 03&body=Check out this article: http://leavesite.com/2017/jjhouCpp1114-03/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://leavesite.com/2017/jjhouCpp1114-03/&title=C++ 新标准 11/14 语言新特性 - 03"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://leavesite.com/2017/jjhouCpp1114-03/&title=C++ 新标准 11/14 语言新特性 - 03"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://leavesite.com/2017/jjhouCpp1114-03/&title=C++ 新标准 11/14 语言新特性 - 03"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://leavesite.com/2017/jjhouCpp1114-03/&title=C++ 新标准 11/14 语言新特性 - 03"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://leavesite.com/2017/jjhouCpp1114-03/&name=C++ 新标准 11/14 语言新特性 - 03&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick='$("#toc-footer").toggle();return false;'><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick='$("#share-footer").toggle();return false;'><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick='$("#nav-footer").toggle();return false;'><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2017 Minfang Lin, Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="http://github.com/Minfang-Lin">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    <script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- Google Analytics -->

<!-- Disqus Comments -->


</body>
</html>
